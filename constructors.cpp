#include "constructors.h"

/**
 * Данный модуль предназначен для формирования инфраструктуры, необходимой
 * для удобного исследования поведения объектной модели C++, главным образом
 * относительно политики различных способов инициализации и уничтожения
 * экземпляров классов, возможно, находящихся в сложных иерархических
 * отношениях с другими классами и имеющими поля пользовательских типов,
 * передачи параметров пользовательских типов в функции и методы и т.п.
 *
 * В этом файле вы можете объявить некоторый класс, являющийся public-
 * наследником предопределенного класса Base прммерно следующим образом:
 *
 *      class Deriver : public Base
 *      {
 *          // определение класса
 *
 *      CLOSE_CLASS(Deriver)
 *
 * Макрос CLOSE_CLASS(ClassName) следует рассматривать как };
 * Его истинная роль прозрачно освещена в файле constructors.h
 *
 * Всякий производный от Base класс наследует одно неконстантное
 * публичное поле name, что предполагает, что вы будете его использовать
 * для удобной идентификации объектов. (примерно так:
 *
 *      Deriver::Deriver(const char* _name)
 *      { name = _name; }
 *
 * Обратите внимание на то, что вы не можете вызвать конструктор поля name
 * в списке инициализации: оно не принадлежит непосредственно классу Deriver
 * (а Base) и уже инициализировано к моменту вызова этого конструктора
 * конструктором Base)
 *
 * В вашем распоряжении также виртуальный геттер count(), который возвращает
 * неконстантную ссылку, позволяющую рапортовать об изменении числа объектов
 * данного класса. (примерно так: count()++; )
 *
 * Также вы можете использовать Base-friend функцию printStatus:
 *
 *       void printStatus(Base *obj, int newCount, const char* method, string newName);
 * 
 * сигнатура которой согласована с форматом ее вывода:
 *
 *       Deriver[ 0 -> 1 ]: default constructor (   [UNNAMED]:0   -> deriver )
 *  
 * - В качестве первого аргумента следует использовать указатель this,
 * - второй указывает, как измениться число объектов данного класса
 *   (напрмер, его можно передать так: count() + 1) - в прммере вывода
 *   это значение -> 1 (было 0 объектов, стало 1)
 * - третий соответствует записи "default constructor" (можно пользоваться
 *   предопределенными константами, см. constructors.h. Например, dc)
 * - четвертый указывает, как изменится имя объекта (стандартный подход:
 *   name + cf(src.memId), где src - сслыка, переданная в копирующий конструктор
 *   или оператор присваивания (где это и может понадобиться), cf - функция, конструирующая
 *   стандартный суффикс имени копии объекта вида oldName:memId copy, который позволяет
 *   однозначно идентифицировать копию и то, с какого конкретно объекта она была создана)
 * 
 * Последняя часть вывода printStatus(...) показывает, что в результате выполнения строки
 * объект с именем "[UNNAMED]" (константа un), расположенный в нулевой ячейке памяти, был
 * преобразован в объект с именем deriver (очевидно, расположенный в том же месте). Такой
 * вывод можно получить от конструктора Deriver с параметром "deriver" (ячейка памяти уже
 * содержит объект "[UNNAMED]", но это не удивительно, так как до конструктора Deriver уже
 * был автоматически вызван конструктор базового класса Base(const char* _name = un) со
 * значеничем по умолчанию un)
 *
 * Раскомментируйте блок ниже для того, чтобы запустить пример:
 */

/*
class Deriver : public Base
{
public:
    Deriver(const char* _name)
    {
        printStatus(this, count() + 1, dc, _name);
        count()++;
        name = _name;
    }

    ~Deriver()
    {
        printStatus(this, count() - 1, ds, sc);
        count()--;
    }

CLOSE_CLASS(Deriver)
*/

/**
 * Обратите внимание на тот факт, что вообще говоря не предполагается, что вы будете использовать
 * Base иным образом, кроме как наследовать от него корни своих иерархий классов. Напрммер, так:
 *
 * Base *p = new Deriver("deriver");
 *
 * В этом случае delete p; не удалит объект корректно. Дело в том, что деструктор класса Base
 * умышленно оставлен невиртуальным. Так как любая перегрузка метода, расположенная в иерархической
 * цепи перегрузок ниже первого объявления ее виртуальной является виртуальной вне зависимости от того,
 * указан этот факт в наследнике или нет, объявление деструктора Base виртуальным сделало бы виртуальными
 * все деструкторы системы, что не согласуется с учебными целями данного модуля: вы должны сами понять,
 * что нужно делать для корректного удаления объектов в контексте полиморфного их использования.
 *
 * Стройте все иерархии так, словно их корень - вами определенный класс (пусть и наследующий Base).
 *
 * Также вы можете заметить, что иногда число объектов классов к заверешнию теста остается большим
 * нуля или даже становится отрицательным. Это означает, что вы не задали соответствующие конструкторы
 * и деструктор корректным образом, а автоматически сгенерированные версии недостаточно хорошо
 * осведомлены о логике ваших объектов и некорректны: например, они не изменяют должным образом
 * счетчик числа объектов класса. Если ваш тест большой и вы хотите увидеть разницу в поведении
 * объектов с корректным и некорректым определениями этих методов, вам может понадобиться сбросить
 * счетчики объектов ваших классов в ноль. Сделать это можно так:
 *
 * YourClass::resetCount();  // подробности см. в примере examples/constructors.cpp
 *
 * Для автоматического запуска в системах *nix с установленными утилитами g++, shell (bash) и sed
 * достаточно набрать в текущей папке
 * 
 *     ./constructors
 *
 * (возможно, понадобиться предварительно разрешить файл на выполнение командой
 *
 *     chmod +x constructors
 *
 * ) Для указания альтернативного расположения файла с исходным кодом вашего теста используйте
 * ключ -f путь_к_файлу. Например так:
 *
 *     ./constructors -f examples/firtual_destructors.cpp
 *
 * Вы должны получить вывод, при условии верного оформления main,  подобный приведенному ниже:

   101	int main(int argc, char **argv) {
   102	
   103	    Deriver d("deriver");
   104	
   105	    return 0;
   106	}
-----------------
   103   Deriver[ 0 -> 1 ]: default constructor (    [UNNAMED]:0   -> deriver      )
   105   Deriver[ 1 -> 0 ]: destructor          (      deriver:0   -> [SCRATCH]    )

 * Обратите внимание, что для корректного вывода может понадобиться значительно расширить
 * окно консоли. (или изменить параметры вывода, см. переменную WIDTH в constructors.h)
 *
 * Скрипт constructors может принимать ключ -b, которым вы, вероятно, будете часто пользоваться - 
 * он отключает подавление вывода сообщений из конструкторов/деструктора базового класса Base.
 * Можно избежать необходимости всяких раз указывать ключ, записав первой строкой main следующее:
 *
 * supressBase = false;  // или вызывайте ./constructors -b
 *
 * (Обратите внимание на то, что в случае добавления этой строки в файл constructors.tmp.cpp в
 * автоматическом режиме (при использовании ключа -b) сообщения компилятора об ошибках в main()
 * будут адресоваться со сдвигом на одну строку относительно оригинального файла)
 *
 * Для корректной работы необходимо верно описать main() - тело функции должно быть заключено
 * в макросы так, как в примере ниже:
 */

// ВНИМАНИЕ
// На данном этапе в теле main() не поддерживаются многострочные конструкции (в несколько строк обычно
// оформляют конструкции управления потоком (циклы, условия и т. д.) и блоки. Например, такие:
//
// for (int i = 0; i < sizeArray; ++i)
//     cout << array[i] << endl;
//
// Пишите при в одну строку:
//
// for (int i = 0; i < sizeArray; ++i) cout << array[i] << endl;
//
// ) При необходимости их использовать в многострочном варианте (а также всем пользователям *nix нe 
// совместимых систем (e.g. MS WINDOWS) следует самостоятельно компилировать constructors.cpp, не используя
// скрипт constructors (а значит, средства расширенного вывода. В остальном все остается функциональным.)


MAIN

//    Deriver d("deriver");
    cout << "Read the constructors.cpp for instructions" << endl;

    return 0;
ENDMAIN

