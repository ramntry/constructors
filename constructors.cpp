#include "constructors.h"

/**
 * Данный модуль предназначен для формирования инфраструктуры, необходимой
 * для удобного исследования поведения объектной модели C++, главным образом
 * относительно политики различных способов инициализации и уничтожения
 * экземпляров классов, возможно, находящихся в сложных иерархических
 * отношениях с другими классами и имеющими поля пользовательских типов,
 * передачи параметров пользовательских типов в функции и методы и т.п.
 *
 * В этом файле вы можете объявить некоторый класс, являющийся public-
 * наследником предопределенного класса Base прммерно следующим образом:
 *
 *      class Deriver : public Base
 *      {
 *          // определение класса
 *
 *      CLOSE_CLASS(Deriver)
 *
 * Макрос CLOSE_CLASS(ClassName) следует рассматривать как };
 * Его истинная роль прозрачно освещена в файле constructors.h
 *
 * Всякий производный от Base класс наследует одно неконстантное
 * публичное поле name, что предполагает, что вы будете его использовать
 * для удобной идентификации объектов. (примерно так:
 *
 *      Deriver::Deriver(const char* _name)
 *      { name = _name; }
 *
 * Обратите внимание на то, что вы не можете вызвать конструктор поля name
 * в списке инициализации: оно не принадлежит непосредственно классу Deriver
 * (а Base) и уже инициализировано к моменту вызова этого конструктора
 * конструктором Base)
 *
 * В вашем распоряжении также виртуальный геттер count(), который возвращает
 * неконстантную ссылку, позволяющую рапортовать об изменении числа объектов
 * данного класса. (примерно так: count()++; )
 *
 * Также вы можете использовать Base-friend функцию printStatus:
 *
 *       void printStatus(Base *obj, int newCount, const char* method, string newName);
 * 
 * сигнатура которой согласована с форматом ее вывода:
 *
 *       Deriver[ 0 -> 1 ]: default constructor (   [UNNAMED]:0   -> deriver )
 *  
 * - В качестве первого аргумента следует использовать указатель this,
 * - второй указывает, как измениться число объектов данного класса
 *   (напрмер, его можно передать так: count() + 1) - в прммере вывода
 *   это значение -> 1 (было 0 объектов, стало 1)
 * - третий соответствует записи "default constructor" (можно пользоваться
 *   предопределенными константами, см. constructors.h. Например, dc)
 * - четвертый указывает, как изменится имя объекта (стандартный подход:
 *   name + cf(src.memId), где src - сслыка, переданная в копирующий конструктор
 *   или оператор присваивания (где это и может понадобиться), cf - функция, конструирующая
 *   стандартный суффикс имени копии объекта вида oldName:memId copy, который позволяет
 *   однозначно идентифицировать копию и то, с какого конкретно объекта она была создана)
 * 
 * Последняя часть вывода printStatus(...) показывает, что в результате выполнения строки
 * объект с именем "[UNNAMED]" (константа un), расположенный в нулевой ячейке памяти, был
 * преобразован в объект с именем deriver (очевидно, расположенный в том же месте). Такой
 * вывод можно получить от конструктора Deriver с параметром "deriver" (ячейка памяти уже
 * содержит объект "[UNNAMED]", но это не удивительно, так как до конструктора Deriver уже
 * был автоматически вызван конструктор базового класса Base(const char* _name = un) со
 * значеничем по умолчанию un)
 *
 * Раскомментируйте блок ниже для того, чтобы запустить пример:
 */

/*
class Deriver : public Base
{
public:
    Deriver(const char* _name)
    {
        printStatus(this, count() + 1, dc, _name);
        count()++;
        name = _name;
    }

    ~Deriver()
    {
        printStatus(this, count() - 1, ds, sc);
        count()--;
    }

CLOSE_CLASS(Deriver)
*/

/**
 * Для автоматического запуска в системах *nix с установленными утилитами g++, shell (bash) и sed
 * достаточно набрать в текущей папке
 * 
 * ./constructors
 *
 * (возможно, понадобиться предварительно разрешить файл на выполнение командой
 *
 * chmod +x constructors
 *
 * ) Вы должны получить вывод, при условии верного оформления main,  подобный приведенному ниже:

   101	int main(int argc, char **argv) {
   102	
   103	    Deriver d("deriver");
   104	
   105	    return 0;
   106	}
-----------------
   103   Deriver[ 0 -> 1 ]: default constructor (    [UNNAMED]:0   -> deriver      )
   105   Deriver[ 1 -> 0 ]: destructor          (      deriver:0   -> [SCRATCH]    )

 * Обратите внимание, что для корректного вывода может понадобиться значительно расширить
 * окно консоли. (или изменить параметры вывода, см. константу WIDTH в constructors.h)
 *
 * Скрипт constructors может принимать ключ -b, которым вы, вероятно, будете часто пользоваться - 
 * он отключает подавление вывода сообщений из конструкторов/деструктора базового класса Base.
 * Можно избежать необходимости всяких раз указывать ключ, записав первой строкой main следующее:
 *
 * supressBase = false;  // или вызывайте constructors -b
 *
 * (Обратите внимание на то, что в случае добавления этой строки в файл constructors.tmp.cpp
 * сообщения компилятора об ошибках в main() будут адресоваться со сдвигом на одну строку
 * относительно оригинального файла)
 *
 * Для корректной работы необходимо верно описать main() - тело функции должно быть заключено
 * в макросы так, как в примере ниже:
 */

// ВНИМАНИЕ
// На данном этапе в теле main() не поддерживаются конструкции управления потоком (циклы, условия
// и т. д.) и блоки. При необходимости их использовать (а также всем пользователям *nix не
// совместимых систем) следует самостоятельно компилировать constructors.cpp, не используя
// скрипт constructors (а значит, средства расширенного вывода. В остальном все остается функциональным.)

MAIN

//    Deriver d("deriver");
    cout << "Read the constructors.cpp for instructions" << endl;

    return 0;
ENDMAIN

